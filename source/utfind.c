/*
    Программа управления светодиодным индикатором уровня стереосигнала
    для устройства
    http://hawelson.blog.cz/1005/vu-metr-2x32led-s-mikrokontrolerem
    MCU: ATmega8, ATmega8L на частоте 1 МГц.
    Версия 2
    7-8 сентября
        исправление ошибок режима "зеркально".
    27 августа 2011
        Добавлена опция компиляции "зеркально" для альтернативного
        варианта печатной платы (#define MIRROR).
    16 августа 2011
        Возможность выбора режима отображения работающего устройства.
    11 августа 2011
        Отображение текущего уровня точкой место линии.
    8-10 августа 2011
        Отображение текущего значения в виде линии, пикового - точкой.
        Возможность выбора линейной или логарифмической шкалы при
        компиляции (#define LOGARIFM).
*/

/***************************************
 * Назначение выводов для линейки
 * светодиодов.
    PC2
    PC3
    PC4
    PC5
    PD0
    PD1
    PD2
    PD3
    PD4
    PB6
    PB7
    PD5
    PD6
    PD7
    PB0
    PB1
 * Выводы управления секциями
    PB2 - правая чётная
    PB3 - правая нечётная
    PB4 - левая  чётная
    PB5 - левая  нечётная
 ***************************************/

#include <avr/io.h>
#include <util/delay.h>

#define LOOP_DELAY  1500

typedef unsigned char   BYTE;
typedef unsigned int    WORD;

/* Константы для АЦП
 ***************************************/
#define ADC_MODE    0b10000000
#define ADC_START   0b01000000
#define ADC_FINISH  0b00010000
    /* Выбор предделителя частоты АЦП */
/*#define ADC_SCALER  0b00000001   :2   */
/*#define ADC_SCALER  0b00000010   :4   */
#define ADC_SCALER  0b00000011  /* :8   */
/*#define ADC_SCALER  0b00000100   :16  */
/*#define ADC_SCALER  0b00000101   :32  */
/*#define ADC_SCALER  0b00000110   :64  */
/*#define ADC_SCALER  0b00000111   :128 */

/* Задержки индикации
 * Tзадержки=2*(время цикла)*(X+1)
 ***************************************/
#define LINE_DELAY  7   /* 5 Задержка для скатывания линии */
#define DOT_DELAY   14  /* 11 Задержка для скатывания пика */
#define DOT_HOLD    199 /* "Зависание" пика */

/* Управление секциями шкалы
 ***************************************/
#define LEFT_BOTTOM     0b00000100
#define LEFT_TOP        0b00001000
#define RIGHT_BOTTOM    0b00010000
#define RIGHT_TOP       0b00100000

/* Режимы работы
 ***************************************/
#define MODE_PEAK       0b00000001
#define MODE_LINE       0b00000010
#define MODE_LINEAR     0b00000100


void UpdateMode(void);
void Show(BYTE bCanel);
void UpdateLevel(WORD wADC, BYTE bCanel);

/* Глобальные переменные
 ***************************************/
BYTE bMode;           /* Режим работы устройства */
BYTE bCount=0;        /* Счётчик для динамической индикации */
BYTE bLine[2]={};     /* Текущее значение для каналов */
BYTE bDot[2]={};      /* Пиковое значение для каналов */
BYTE bCountLine[2]={};
BYTE bCountDot[2]={};

/* Зависимости для преобразования
 * результата АЦП
 ***************************************/
#define FIRST_STEP 8    /* Смещение начала линейной шкалы */

/* Массив для нелинейного преобразования
 ***************************************/
/* Логарифмическая зависимость шаг 0.75 dB */
WORD tLog[]={
        4,   5,   6,   7,   9,   11,  13,  15,
        18,  21,  25,  30,  35,  42,  50,  59,
        70,  84,  99,  118, 141, 167, 199, 236,
        280, 333, 396, 471, 559, 665, 790, 939,
        1023};
// Массив нелогарифмической прогрессии был удален
// потому что не нужон


/* Массив управления светодиодами.
 * Для альтернативной версии платы
 * используется два массива.
 ***************************************/
// Отключены пины на портах PB0, PB1, PC2, PC3, PC4, PC5
// по средствам зануления их битов
BYTE tIndik[]={
        /* Порт B      Порт C      Порт D */
        0b00000000, 0b00000000, 0b00000000,
        0b00000000, 0b00000000, 0b00000000, /* =0 */
        0b00000000, 0b00000000, 0b00000000,
        0b00000000, 0b00000000, 0b10000000,
        0b00000000, 0b00000000, 0b11000000,
        0b00000000, 0b00000000, 0b00000000, /* =1 */
        0b00000000, 0b00000000, 0b11100000,
        0b10000000, 0b00000000, 0b11100000,
        0b11000000, 0b00000000, 0b11100000,
        0b11000000, 0b00000000, 0b11110000,
        0b11000000, 0b00000000, 0b11111000,
        0b11000000, 0b00000000, 0b11111100,
        0b11000000, 0b00000000, 0b11111110,
        0b11000000, 0b00000000, 0b11111111,
        0b11000000, 0b00000000, 0b11111111,
        0b11000000, 0b00000000, 0b11111111,
        0b11000000, 0b00000000, 0b11111111,
        0b11000000, 0b00000000, 0b11111111  /* =16 */
// Все, что под MIRROR и так не работает без объявления
// переменной MIRROR, но с комментарием это более явно
// #ifdef MIRROR
//        ,0b00000000, 0b00000000, 0b00000000,
//         0b00000000, 0b00000000, 0b00000000, /* =0 */
//         0b00000000, 0b00000100, 0b00000000, /* =1 */
//         0b00000000, 0b00001100, 0b00000000,
//         0b00000000, 0b00011100, 0b00000000,
//         0b00000000, 0b00111100, 0b00000000,
//         0b00000000, 0b00111100, 0b00000001,
//         0b00000000, 0b00111100, 0b00000011,
//         0b00000000, 0b00111100, 0b00000111,
//         0b00000000, 0b00111100, 0b00001111,
//         0b00000000, 0b00111100, 0b00011111,
//         0b01000000, 0b00111100, 0b00011111,
//         0b11000000, 0b00111100, 0b00011111,
//         0b11000000, 0b00111100, 0b00111111,
//         0b11000000, 0b00111100, 0b01111111,
//         0b11000000, 0b00111100, 0b11111111,
//         0b11000001, 0b00111100, 0b11111111,
//         0b11000011, 0b00111100, 0b11111111  /* =16 */
// #endif
        };


/*************************************
 * Запуск микроконтоллёра.
 *************************************/
int main()
{
    BYTE bCanel;

    /* Инициализация портов для индикации */
    DDRB=0b11111100; /* Убрали PB0 и PB1 из выводов*/
    DDRC=0b11000000; /* Оставили только PC6 и PC7*/
    DDRD=0b11111111;

    while (1)
    {
        if (!bCount) UpdateMode();

        bCanel=bCount & 0x01;

        /* Подготовка к запуску АЦП */
        ADMUX=(bCanel) | 0b11000000;

        Show (bCanel);

        /* Запуск АЦП и задержка */
        ADCSRA=ADC_MODE | ADC_SCALER | ADC_START;
        _delay_us(LOOP_DELAY);
        while (!(ADCSRA & ADC_FINISH));

        /* Преобразование результата АЦП */
        UpdateLevel (ADC, bCanel);

        /* Сброс флага прерывания АЦП */
        ADCSRA=ADC_MODE | ADC_SCALER | ADC_FINISH;

        bCount++;
    }
}


/***********************************************
 * Функция опроса состояния перемычек
 * и обновления режима индикации.
 * PD4=1 - отображение пикового уровня.
 * PD5=1 - текущий уровень в виде линии,
 *         иначе - в виде точки.
 * PB7=1 - линейное преобразование АЦП.
 * Состоянию "1" соответствует отсутствие
 * перемычки.
 ***********************************************/
void UpdateMode(void)
{
    /* Гасим индикатор и переводим
     * порты в режим ввода
     ***********************************/
    PORTB=0b00000000;
    _delay_us(25);

    PORTB=0b11000011;
    PORTC=0b00111100;
    PORTD=0b11111111;

    DDRB=0b00111100;
    DDRC=0b11000011;
    DDRD=0b00000000;

    bMode=0;

    if (PIND & 0x10) bMode=bMode | MODE_PEAK;     // Пик
    if (PIND & 0x20) bMode=bMode | MODE_LINE;     // Линия
    // Убираем проверку перемычки, чтобы всегда использовать
    // логарифмический режим работы
    // if (PINB & 0x80) bMode=bMode | MODE_LINEAR;   // Линейно

    PORTB=0b00000000;
    PORTC=0b00000000;
    PORTD=0b00000000;

    DDRB=0b11111100;
    DDRC=0b11000000;
    DDRD=0b11111111;
    return;
}


void Show(BYTE bCanel)
{
    BYTE bPortB, bPortC, bPortD;
    BYTE l, p;

    /* Гасим индикатор и
     * немного ждём.
     ***********************************/
    PORTB=0;
    PORTC=0;
    PORTD=0;
    bPortB=0;
    bPortC=0;
    bPortD=0;
    _delay_us(25);

    /* Выбор индицируемой части индикатора
     * и, соответственно, открытого
     * транзистора
     ***********************************/
    switch(bCount & 0x03)
    {
        case 0:
            bPortB=LEFT_BOTTOM;
            break;
        case 1:
            bPortB=LEFT_TOP;
            break;
        case 2:
            bPortB=RIGHT_BOTTOM;
            break;
        case 3:
            bPortB=RIGHT_TOP;
            break;
    }

    /* Получение индексов для
     * нужного канала.
     ***********************************/
    if (bCount & 0x02)
    {
        l=bLine[1];
        p=bDot[1];
    }
    else
    {
        l=bLine[0];
        p=bDot[0];
    }

    /* Коррекция индексов в зависимости
     * от индицируемой половины шкалы и
     * от режима индикации.
     ***********************************/
    if (bCount & 0x01)
    {
        if ((l & 0x01) && !(bMode & MODE_LINE)) l=2;
        else l=l+2;
        if (p & 0x01) p=2;
        else p=p+2;
    }
    else
    {
        if (!(l & 0x01) && !(bMode & MODE_LINE)) l=2;
        else l=l+3;
        if (p & 0x01) p=p+3;
        else p=2;
    };

    /* Умножение индексов на 1.5 .
     * Получаем индекс в диапазоне
     * от 3 до 51 с шагом 3
     ***********************************/
    l=l & 0xfe;
    l=l+(l>>1);
    p=p & 0xfe;
    p=p+(p>>1);

    /* Для альтернативной платы разные
     * каналы используют разные массивы
     * управления индикацией.
     ***********************************/
    // #ifdef MIRROR
    //     if (!(bCount & 0x02))
    //     {
    //         l=l+54;
    //         p=p+54;
    //     }
    // #endif

    if (bMode & MODE_LINE)
    {
        bPortB=bPortB | tIndik[l];
        bPortC=bPortC | tIndik[l+1];
        bPortD=bPortD | tIndik[l+2];
    }
    else
    {
        bPortB=bPortB | (tIndik[l] & (~tIndik[l-3]));
        bPortC=bPortC | (tIndik[l+1] & (~tIndik[l-2]));
        bPortD=bPortD | (tIndik[l+2] & (~tIndik[l-1]));
    }

    if (bMode & MODE_PEAK)
    {
        bPortB=bPortB | (tIndik[p] & (~tIndik[p-3]));
        bPortC=bPortC | (tIndik[p+1] & (~tIndik[p-2]));
        bPortD=bPortD | (tIndik[p+2] & (~tIndik[p-1]));
    }

    PORTC=bPortC;
    PORTD=bPortD;
    PORTB=bPortB;
    return;
}


/* Функция преобразования результата АЦП
 * и обновления текущего и пикового
 * уровня соответствующего канала.
 **************************************/
void UpdateLevel(WORD wADC, BYTE bCanel)
{
    BYTE bLevel;

    /* Преобразование результата АЦП */
    // if (bMode & MODE_LINEAR) bLevel=(wADC+(32-FIRST_STEP))>>5;
    // else
    // {
    // Отключено использование линейного режима.
    // Для включения раскомментировать if-else блок.
    for (bLevel=0; bLevel <= 32; bLevel++)
    {
        if (tLog[bLevel] >= wADC) break;
    }
    // }

    /* Обновление текущего значения */
    if (bLevel >= bLine[bCanel])
    {
        bLine[bCanel]=bLevel;
        bCountLine[bCanel]=LINE_DELAY;
    }
    else
    {
        if (bCountLine[bCanel]) bCountLine[bCanel]--;
        else
        {
            bLine[bCanel]--;
            bCountLine[bCanel]=LINE_DELAY;
        }
    }

    /* Обновление пикового уровня */
    if (bLine[bCanel] > bDot[bCanel])
    {
        bDot[bCanel]=bLine[bCanel];
        bCountDot[bCanel]=DOT_HOLD;
    }
    else
    {
        if (bCountDot[bCanel]) bCountDot[bCanel]--;
        else
        {
            bCountDot[bCanel]=DOT_DELAY;
            if (bDot[bCanel]) bDot[bCanel]--;
        }
    }
}
