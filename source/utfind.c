/*
    Программа управления светодиодным индикатором уровня стереосигнала
    для устройства
    http://hawelson.blog.cz/1005/vu-metr-2x32led-s-mikrokontrolerem
    MCU: ATmega8, ATmega8L на частоте 1 МГц.
    Версия 3
    08.11.25
        - исключено использование режима LEANER 
        - переделана линейка с 32 до 20 светодиодов
    Версия 2
    7-8 сентября
        исправление ошибок режима "зеркально".
    27 августа 2011
        Добавлена опция компиляции "зеркально" для альтернативного
        варианта печатной платы (#define MIRROR).
    16 августа 2011
        Возможность выбора режима отображения работающего устройства.
    11 августа 2011
        Отображение текущего уровня точкой место линии.
    8-10 августа 2011
        Отображение текущего значения в виде линии, пикового - точкой.
        Возможность выбора линейной или логарифмической шкалы при
        компиляции (#define LOGARIFM).
*/

/***************************************
 * Назначение выводов для линейки
 * светодиодов.
    PD0
    PD1
    PD2
    PD3
    PD4
    PB6
    PB7
    PD5
    PD6
    PD7
 * Выводы управления секциями
    PB2 - правая чётная
    PB3 - правая нечётная
    PB4 - левая  чётная
    PB5 - левая  нечётная
 ***************************************/

#include <avr/io.h>
#include <util/delay.h>

#define LOOP_DELAY  1500

typedef unsigned char   BYTE;
typedef unsigned int    WORD;

/* Константы для АЦП
 ***************************************/
#define ADC_MODE    0b10000000
#define ADC_START   0b01000000
#define ADC_FINISH  0b00010000
    /* Выбор предделителя частоты АЦП */
/*#define ADC_SCALER  0b00000001   :2   */
/*#define ADC_SCALER  0b00000010   :4   */
#define ADC_SCALER  0b00000011  /* :8   */
/*#define ADC_SCALER  0b00000100   :16  */
/*#define ADC_SCALER  0b00000101   :32  */
/*#define ADC_SCALER  0b00000110   :64  */
/*#define ADC_SCALER  0b00000111   :128 */

/* Задержки индикации
 * Tзадержки=2*(время цикла)*(X+1)
 ***************************************/
#define LINE_DELAY  7   /* 5 Задержка для скатывания линии */
#define DOT_DELAY   14  /* 11 Задержка для скатывания пика */
#define DOT_HOLD    199 /* "Зависание" пика */

/* Управление секциями шкалы
 ***************************************/
#define LEFT_BOTTOM     0b00000100
#define LEFT_TOP        0b00001000
#define RIGHT_BOTTOM    0b00010000
#define RIGHT_TOP       0b00100000

/* Режимы работы
 ***************************************/
#define MODE_PEAK       0b00000001
#define MODE_LINE       0b00000010


void UpdateMode(void);
void Show(BYTE bCanel);
void UpdateLevel(WORD wADC, BYTE bCanel);

/* Глобальные переменные
 ***************************************/
BYTE bMode;           /* Режим работы устройства */
BYTE bCount=0;        /* Счётчик для динамической индикации */
BYTE bLine[2]={};     /* Текущее значение для каналов */
BYTE bDot[2]={};      /* Пиковое значение для каналов */
BYTE bCountLine[2]={};
BYTE bCountDot[2]={};

/* Зависимости для преобразования
 * результата АЦП
 ***************************************/
/* Смещение начала линейной шкалы - удалено*/

/* Массив для нелинейного преобразования
 ***************************************/
/* Логарифмическая зависимость */
WORD tLog[]={
     // дополнительная единица в начале просто для удобства 
        1, 1, 12, 22, 40, 72,
        102, 128, 161, 204, 242, 
        288, 363, 407, 484, 575, 
        645, 724, 813, 912, 1023
    };
// Массив нелогарифмической прогрессии был удален
// потому что не нужон


/* Массив управления светодиодами.
 ***************************************/
BYTE tIndik[]={
        /* Порт B     Порт D */
        0b00000000, 0b00000000, /* =0 */
        0b00000000, 0b10000000, /* =1 */
        0b00000000, 0b11000000,
        0b00000000, 0b11100000,
        0b10000000, 0b11100000,
        0b11000000, 0b11100000,
        0b11000000, 0b11110000,
        0b11000000, 0b11111000,
        0b11000000, 0b11111100,
        0b11000000, 0b11111110,
        0b11000000, 0b11111111,  /* =10 */
    };


/*************************************
 * Запуск микроконтоллёра.
 *************************************/
int main()
{
    BYTE bCanel;

    /* Инициализация портов для индикации */
    DDRB=0b11111100; /* Убрали PB0 и PB1 из выводов*/
    DDRC=0b11000000; /* Оставили только PC6 и PC7*/
    DDRD=0b11111111;

    while (1)
    {
        if (!bCount) UpdateMode();

        bCanel=bCount & 0x01;

        /* Подготовка к запуску АЦП */
        ADMUX=(bCanel) | 0b11000000;

        Show (bCanel);

        /* Запуск АЦП и задержка */
        ADCSRA=ADC_MODE | ADC_SCALER | ADC_START;
        _delay_us(LOOP_DELAY);
        while (!(ADCSRA & ADC_FINISH));

        /* Преобразование результата АЦП */
        UpdateLevel (ADC, bCanel);

        /* Сброс флага прерывания АЦП */
        ADCSRA=ADC_MODE | ADC_SCALER | ADC_FINISH;

        bCount++;
    }
}


/***********************************************
 * Функция опроса состояния перемычек
 * и обновления режима индикации.
 * PD4=1 - отображение пикового уровня.
 * PD5=1 - текущий уровень в виде линии,
 *         иначе - в виде точки.
 * Состоянию "1" соответствует отсутствие
 * перемычки.
 ***********************************************/
void UpdateMode(void)
{
    /* Гасим индикатор и переводим
     * порты в режим ввода
     ***********************************/
    PORTB=0b00000000;
    _delay_us(25);

    PORTB=0b11000011;
    PORTC=0b00111100;
    PORTD=0b11111111;

    DDRB=0b00111100;
    DDRC=0b11000011;
    DDRD=0b00000000;

    bMode=0;

    if (PIND & 0x10) bMode=bMode | MODE_PEAK;     // Пик
    if (PIND & 0x20) bMode=bMode | MODE_LINE;     // Линия
    // Убрана проверка перемычки линейного преобразования,
    // чтобы всегда использовать режим работы линии по 
    // логарифмической шкале

    PORTB=0b00000000;
    PORTC=0b00000000;
    PORTD=0b00000000;

    DDRB=0b11111100;
    DDRC=0b11000000;
    DDRD=0b11111111;
    return;
}


void Show(BYTE bCanel)
{
    BYTE bPortB, bPortD;
    BYTE l, p;

    PORTB = 0;
    PORTD = 0;
    bPortB = 0;
    bPortD = 0;
    _delay_us(25);

    /* Выбор индицируемой части индикатора
     * и, соответственно, открытого
     * транзистора
     ***********************************/
    switch(bCount & 0x03)
    {
        case 0: bPortB = LEFT_BOTTOM; break;
        case 1: bPortB = LEFT_TOP; break;
        case 2: bPortB = RIGHT_BOTTOM; break;
        case 3: bPortB = RIGHT_TOP; break;
    }

    if (bCount & 0x02)
    {
        l = bLine[1];
        p = bDot[1];
    }
    else
    {
        l = bLine[0];
        p = bDot[0];
    }

    // Коррекция индексов в зависимости от индуцируемой половины шкалы убрана
    // Если актуален режим точки, то l нам не важна, сбрасываем к 2
    if (bMode & MODE_LINE)
    {
        // нечетное l приводим к ближайшему большему четному
        if (l & 0x01) l = l + 1;

        bPortB |= tIndik[l];
        bPortD |= tIndik[l + 1];
    }
    else
    {
        // нечетную p приводим к четной
        if (p & 0x01) p = p + 1;

        bPortB |= (tIndik[p] & (~tIndik[p-2]));
        bPortD |= (tIndik[p+1] & (~tIndik[p-1]));
    }

    PORTB = bPortB;
    PORTD = bPortD;
    return;
}


/* Функция преобразования результата АЦП
 * и обновления текущего и пикового
 * уровня соответствующего канала.
 **************************************/
void UpdateLevel(WORD wADC, BYTE bCanel)
{
    BYTE bLevel;

    /* Преобразование результата АЦП */
    // Удалено использование линейного режима.
    for (bLevel=0; bLevel <= 20; bLevel++)  // заменено 32 на 20
    {
        if (tLog[bLevel] >= wADC) break;
    }

    /* Обновление текущего значения */
    if (bLevel >= bLine[bCanel])
    {
        bLine[bCanel]=bLevel;
        bCountLine[bCanel]=LINE_DELAY;
    }
    else
    {
        if (bCountLine[bCanel]) bCountLine[bCanel]--;
        else
        {
            bLine[bCanel]--;
            bCountLine[bCanel]=LINE_DELAY;
        }
    }

    /* Обновление пикового уровня */
    if (bLine[bCanel] > bDot[bCanel])
    {
        bDot[bCanel]=bLine[bCanel];
        bCountDot[bCanel]=DOT_HOLD;
    }
    else
    {
        if (bCountDot[bCanel]) bCountDot[bCanel]--;
        else
        {
            bCountDot[bCanel]=DOT_DELAY;
            if (bDot[bCanel]) bDot[bCanel]--;
        }
    }
}
